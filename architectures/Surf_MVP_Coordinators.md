# **Coordinated Surf MVP**

## Содержание

## Предисловие

Этот архитектурный паттерн переродился из уже давно принятого за стандарт у нас в студии **SurfMVP**. Причиной появления новой надстройки над **SurfMVP** послужили проблемы с навгиацией в приложениях, которые начали разрастаться со временем, набирать массу сложных фич, реализация которых затруднялась при использование **routers**, которые мы ввели в **SurfMVP**. 

Из-за того, что навигация в приложение написанном на **SurfMVP** строится посредством обращение одного модуля через router к другому модулю. Схематично это выглядит следующим образом: 

![SurfMVPNavigation](../img/CoordinatedSurfMVP/surf_mvp_navigation.jpeg)

<p align="center">Схема навигации в Surf MVP</p>
**Coordinated Surf MVP** меняет концепт навигации в приложение, убирает акцент с отдельно существующих модулей объединяя их в группы модулей, выполняющих общие действия. 

## Описание архитектуры 

В основе архитектуры **Coordinated Surf MVP** лежит привычный для нас **Surf MVP**. Подробней можно прочитать [тут](Surf_MVP.md). 

![SurfMVPNavigation](../img/CoordinatedSurfMVP/coordinated_surf_mvp.jpeg)

<p align="center">Схема Coordinated Surf MVP – модуль</p>
**Coordinated SurfMVP** – это архитектурный паттерн, в котором, в отличие от SurfMVP, мы убрали сущность Router, которая находилась внутри каждого отдельного модуля. Парадигма построения приложения немного изменилась. Модули теперь не являются полностью независимыми. Каждый модуль, за исключением полностью переиспользуемых, находится в отдельном обособленном UserFlow, который по задумке должен выполнять какое-то общее действие, приводящее пользователя к желаемому результату.

Например, набор экранов авторизации может является примером такого флоу. 

В Coordinated SurfMVP сущность Router заменила сущность [Coordinator](http://khanlou.com/2015/01/the-coordinator/), которая теперь отвечает за работу навигации не одного отдельного модуля, а набора модулей, которые связаны друг с другом логически. Это упрощает навигацию и работу с приложением. Схематично приложение будет выглядить так: 

![SurfMVPNavigation](../img/CoordinatedSurfMVP/сoordinated_surf_mvp_scheme.jpeg)

<p align="center">Схема приложения с Coordinated Surf MVP</p>
В самом верху стоит ApplicationCoordinator, который отвечает за первоначальный роутинг в приложении. К примеру, кейс, когда пользователь авторизован, тогда мы его отправим сразу в основную часть приложения, в противном случае, мы отправим его на экран авторизации.

Схематично навигация в приложение выглядит теперь таким образом. Каждый отдельный UserFlow обращается к собственному координатору, который уже в свою очередь решает, что будет происходить в дальнейшем. Ответственность по передачи данных и инициации дальнейшей навигации теперь лежит на координаторе, он уже связывается с другими модулями или другими координаторами, чтобы продолжить построение стека навигации.

![SurfMVPNavigation](../img/CoordinatedSurfMVP/coordniated_surf_mvp_navigation.jpeg)

<p align="center">Схема навигации в Coordinated Surf MVP</p>
## Плюсы и минусы Coordinated SurfMVP

### **Плюсы:**

##### Переиспользование

Основной плюс подхода с координаторами — возможность переиспользовать целые блоки навигации внутри приложения. Теперь из любого места в приложении есть возможность вызвать этот координатор и не думать ни о чем, кроме как о завершении его работы.

##### Навигация

Так как логика навигации обособлена внутри отдельного координатора, теперь гораздо удобней следить за навигацией: достаточно открыть один файл и вся картина перед глазами. Нет больше необходимости протыкивать все отдельные модули, чтобы понять, что за чем тянется, собирать приложение и смотреть в дизайн.

##### Проектирование

Удобнее проектировать в больших командах. Достаточно на этапе проектирования отдельной новой фичи выделить время на построение всей навигации и инициализации всех модулей, после чего делегировать разработку большому количеству разработчиков, и уже намного меньше будет возникать проблем с интеграцией этих экранов между друг другом. 

Для этого стоит первым делом инициализировть все модули и описать их ModuleOutput и ModuleInput. После чего можно полностью реализовать Coordinator и связать все модули. Данную задачу может выполнять один человек. После данного этапа несколько разработчиков могут комфортно разрабатывать несколько модулей. 

##### Deeplinks и Push-Notifications

Интеграция Deeplinks и Push-Notifications перестала быть головной болью. Coordinated SurfMVP позволяют очень просто реализовать работу с любой внешней навигацией. Подробней про это можно прочитать в статье [Панова](https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-ii-b5ab3eb4a74). 

<details>
<summary>Подробней про реализацию</summary>

Для того чтобы держать всю информацию о навигации в одном месте создаем enum `DeepLinksOptions` в нем определяются все конечные модули, до куда мы хотим добраться. Далее необходимо реализовать методы по инициализации этого enum из мест где обрабатываются DeepLinks и/или Push-Notifications.

После чего экземпляры данного enum необходимо пробросить по методам `start(with deepLinkOption: DeepLinkOption?)` до координатора, который сможет отобразить целевой экран. Таким образом выстраивается цепочка экранов, которые необходимо отобразить. 

В случае если DeepLink или Push-Notification приходит в момент, когда приложение активно, то в координаторах необходимых для построения стека приложения нам необходимо определить методы `handle(deepLinkOption: DeepLinkOption)`, которые позволят добраться до нужного координатора без пересоздания. 

Для определения, создан ли уже нужный дочерний координатор необходимо использовать generic-метод `hasDependency<T>(ofType: T.Type)`, и уже основываясь на полученном зачение необходимо обрабатывать методы start или handle.
</details>